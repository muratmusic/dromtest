Суть задания: 
Разработать приложение на Objective-C для iPhone без использования Interface Builder,
версия iOS 7.0+, без использования сторонних фреймворков, только iOS SDK.

1) Необходимо создать приложение, основанное на UINavigationController,
с поддержкой горизонтальной и вертикальной ориентации.
2) Во ViewController'е разместить UICollectionView, количество ячеек - 6,
ширина ячейки - ширина экрана с полями по 10 пикселей со всех сторон. Высота ячейки равна ширине.
3) В каждую ячейку загрузить асинхронно по мере необходимости (при появлении на экране)
картинку с Интернета (любую, но не меньше 800 пикселей в ширину и 600 в высоту).
4) Если картинка хоть раз загрузилась, то она должна показываться потом даже без соединения с Интернетом
(оффлайн кэш).
5) При нажатии на ячейку, в которой уже загрузилась картинки, ячейка должна анимированно уезжать вправо
до конца экрана, после чего все оставшиеся снизу ячейки должны сдвинуться анимированно вверх
на одну ячейку, чтобы занять место удаленной ячейки.
6) Добавить к UICollectionView контролл "pull-to-refresh", который должен полностью восстановить
исходное состояние UICollectionView и заново загружать все скачанные ранее картинки
(восстанавливать состояние можно без анимации).


ЧТО ДОДЕЛАТЬ:

1) Отображение сообщения когда интернет-соединение недоступно
2) Отображение надписи в проблемных ячейках: например "Изображение по заданному URL недоступно"
3) Обработка таймаута - например не допускать чтобы пользователь ждал более 30 секунд загрузку изображения,
в противном случае показывать "Слишком долгое ожидание / сервер не отвечает"
4) В случае если слишком долгая загрузка (предыдущий пункт) или обрыв соединения, информировать пользователя о необходимости
"Pull down to refresh" чтобы попытаться загрузить картинки заново
5) Выяснить у заказчика данного проекта:
нужно ли нам загрузить картинки после восстановления интернет-соединения, если не удалось успеть до обрыва соединения?
7) Сделать ограничение на размер кэша в памяти (см. ImageCache)
11) Нужна обработка ошибок в нескольких методах: мы предполагаем что у нас всё в порядке, что хватает дискового пространства,
что успешно сохранилась картинка в виде файла.
12) НЕДОСТАТОК ТЕКУЩЕЙ РЕАЛИЗАЦИИ: при большом количестве картинок они все после их загрузки хранятся в памяти
(ImageData имеет ссылку на картинку полученную из ImageCache). Этот недостаток можно устранить:
а) ограничить максимально допустимое количество картинок в кэше памяти (см. ImageCache)
б) выгружать из памяти те картинки которые в настоящий момент не показываем на экране (оставлять только в файловом кэше, см. ImageCache)
13) Чтобы на всех симуляторах был Full Screen, необходимо использовать картинки Launch Screen всех нужных размеров



Замечания от компании Noveo (тестовое задание заказывали не они), некоторые моменты спорны:

+ использование extern для объявления констант
+ использование weakself
+ публичные интерфейсы классов относительно чистые

- использование устаревшего способа задания enum
Мой ответ: спасибо, поизучаю

- ImageData - это и модель, и контроллер, который обращается к shared сущностям.
В нём находится основная часть логики по скачиванию/кэшированию картинок, хотя лучше было бы её вынести отдельно.

Мой ответ: да, ImageData имеет в себе часть бизнес-логики, я это сделал ради того чтобы не увеличивать количество проводов между чёрными ящиками, зато в данном варианте ImageData максимально удобен для использования в связке с ImageCell. И ещё если уж заговорили про модель - как насчёт экспертного мнения из Википедии?

ЦИТАТА из Википедии:

Наиболее частые ошибки

Начинающие программисты очень часто трактуют архитектурную модель MVC как пассивную модель MVC: модель выступает исключительно совокупностью функций для доступа к данным, а контроллер содержит бизнес-логику. В результате — код моделей по факту является средством получения данных из СУБД, а контроллер — типичным модулем, наполненным бизнес-логикой (см. «скрипт» в терминологии веб-программирования). В результате такого понимания — MVC-разработчики стали писать код, который Pádraic Brady (известный в кругах сообщества «Zend Framework») охарактеризовал как «ТТУК» («Толстые, тупые, уродливые контроллеры»; Fat Stupid Ugly Controllers):
Среднестатистический ТТУК получал данные из БД (используя уровень абстракции базы данных, делая вид, что это модель) или манипулировал, проверял, записывал, а также передавал данные в Представление. Такой подход стал очень популярен потому, что использование таких контроллеров похоже на классическую практику использования отдельного php-файла для каждой страницы приложения.
— The M in MVC: Why Models are Misunderstood and Unappreciated Pádraic Brady перевод
Но в объектно-ориентированном программировании используется активная модель MVC, где модель — это не только совокупность кода доступа к данным и СУБД, но и вся бизнес-логика; также, модели могут инкапсулировать в себе другие модели.

Контроллеры же, — как элементы информационной системы, ответственны лишь за:

- Приём запроса от пользователя;
- Анализ запроса;
- Выбор следующего действия системы, соответственно результатам анализа (например, передача запроса другим элементам системы);

Только в этом случае контроллер становится «тонким» и выполняет исключительно функцию связующего звена (glue layer) между отдельными компонентами информационной системы.

КОНЕЦ ЦИТАТЫ



В самом коде тоже достаточно много проблемных мест - например,
NSURLSession каждый раз создаётся заново и теряются, не оставлено никакой возможности для отмены только что созданного запроса -
а для загрузчика картинок эта часть функциональности - критично важная.
Мой ответ: ценное замечание, в следующий раз я планирую использовать более удобные высокоуровневые средства iOS, например которые есть в самом классе UIImage.

- `ImageCache->sharedInstance` - каждая строчка создания синглтона обладает английским комментарием
(хотя остальные комментарии в проекте на русском).
Мой ответ: это в конкретном случае мелочи, не имеющие значения. Тестовое задание делалось для проверки русскоязычными экспертами.

- Код для анимации ячейки был просто скопирован из https://www.raizlabs.com/dev/2014/02/animating-items-in-a-uicollectionview/.
Использование готового решения - это хорошо, но по заданию нужно было написать его самостоятельно.
Мой ответ: гораздо важнее - насколько я понимаю конкретную область кода. Мне было важно в тот момент успеть быстрее выполнить тестовое задание, чем не выполнить его вообще.




ВТОРОЙ ОТВЕТ ОТ NOVEO:

Улучшить этот класс можно было бы очень просто

1. Использовать объект класса NSURLSession для разных запросов - его принципиальное преимущество перед NSURLConnection
2. Возвращать объект, связанный с NSURLSessionDataTask из метода loadImageOnSuccess:onError:, чтобы была возможность отменить запрос для ячейки, пропавшей с экрана
3. Избавиться от огромной вложенности, перегруппировав if-else и/или разбив код на несколько методов
4. Требует уже чуть больше работы - разбить entity и загрузку, выделить отдельную сущность-загрузчик, как это сделано с сущностью-кэшем. Тогда очевидным становится пункт 1, и появляется возможность управлять всеми этими запросами - отменять, ограничивать количество одновременных запросов. В текущем проекте это не является обязательным требованием, однако такой подход значительно повышает читаемость и пригодность кода для дальнейшего расширения, не особо увеличивая затраты на его производство (разница - в создании еще одного класса).
